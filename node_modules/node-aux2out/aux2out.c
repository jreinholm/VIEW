#include "aux2out.h"

#define AUX_TIP_SET() gpio_set_output(SUNXI_PORT_D_BASE, SUNXI_PIO_15)
#define AUX_TIP_CLR() gpio_clear_output(SUNXI_PORT_D_BASE, SUNXI_PIO_15)
#define AUX_RING_SET() gpio_set_output(SUNXI_PORT_D_BASE, SUNXI_PIO_14)
#define AUX_RING_CLR() gpio_clear_output(SUNXI_PORT_D_BASE, SUNXI_PIO_14)

uint8_t aux2out_init()
{
    gpio_init();

    gpio_cfg_output(SUNXI_PORT_D_BASE, SUNXI_PIO_15_IDX);
    gpio_cfg_output(SUNXI_PORT_D_BASE, SUNXI_PIO_14_IDX);

    AUX_RING_CLR();
    AUX_TIP_CLR();

    return 0;
}

int64_t _microSecondDiff(struct timeval *t1, struct timeval *t0)
{
    if(t1 && t0)
    {
        int64_t seconds = t1->tv_sec - t0->tv_sec;
        int64_t micros = t1->tv_usec - t0->tv_usec;
        return micros + (seconds * 1000000);
    }
    else
    {
        return 0;
    }
}

uint8_t aux2out_pulse(uint32_t lengthMs, uint8_t invert)
{
    struct timeval startTime, now;
    gettimeofday(&startTime, 0);
    if(lengthMs)
    {
        if(invert) AUX_TIP_SET(); else AUX_TIP_CLR();
        for(;;)
        {
            usleep(10);
            gettimeofday(&now, 0);
            int64_t diff = _microSecondDiff(&now, &startTime) / 1000;
            if(diff >= lengthMs) break;
        }
        if(invert) AUX_TIP_CLR(); else AUX_TIP_SET();
    }
    else
    {
        if(invert) AUX_TIP_CLR(); else AUX_TIP_SET();
    }
    return 0;
}


