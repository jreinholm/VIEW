#include <unistd.h>
#include <node.h>
#include <string.h>
#include <v8.h>
//#include <iostream>

extern "C" {
#include "aux2out.h"
}

using namespace v8;

// the 'baton' is the carrier for data between functions
struct Aux2outBaton
{
    // required
    uv_work_t request;                  // libuv
    Persistent<Function> callback;      // javascript callback

    // optional : data goes here.
    // data that doesn't go back to javascript can be any typedef
    // data that goes back to javascript needs to be a supported type

    // inputs
    int32_t aux2outPulseMs;
    bool aux2outInvert;
    int8_t errorCode;
};

// called by libuv worker in separate thread
static void Aux2outAsync(uv_work_t *req)
{
    Aux2outBaton *baton = static_cast<Aux2outBaton *>(req->data);
    
    //std::cout << "aux2outPulseMs: " << baton->aux2outPulseMs << "\n\r";

    // run aux2out (blocking)
    uint8_t err = aux2out_pulse(baton->aux2outPulseMs, baton->aux2outInvert ? 1 : 0);
}

// called by libuv in event loop when async function completes
static void Aux2outAsyncAfter(uv_work_t *req, int status)
{
    // get the reference to the baton from the request
    Aux2outBaton *baton = static_cast<Aux2outBaton *>(req->data);

    // set up return arguments
    Handle<Value> argv[] =
        {
            Handle<Value>(Number::New(baton->errorCode)),
        };

    int argc = 1;

    // execute the callback
    baton->callback->Call(Context::GetCurrent()->Global(), argc, argv);

    // dispose the callback object from the baton
    baton->callback.Dispose();

    // delete the baton object
    delete baton;
}

// javascript callable function
Handle<Value> Aux2out(const Arguments &args)
{
    // create 'baton' data carrier
    Aux2outBaton *baton = new Aux2outBaton;

    // get callback argument
    if (args.Length() <= (1) || !args[1]->IsFunction()) {
    return ThrowException(Exception::TypeError(
      String::New("Argument 1 must be a function")));
    }
    Handle<Function> cb = Handle<Function>::Cast(args[1]);

    if (args.Length() <= (0) || !args[0]->IsObject()) {
    return ThrowException(Exception::TypeError(
      String::New("Argument 0 must be an Object")));
    }
    Handle<Array> options = Handle<Array>::Cast(args[0]);

    // setup defaults
    baton->aux2outPulseMs = 200;
    baton->aux2outInvert = false;

    // validate and attach options argument
    Local<Value> aux2outPulseMs = options->Get(String::New("lengthMs"));
    Local<Value> aux2outInvert = options->Get(String::New("invert"));

    if (aux2outPulseMs->IsNumber()) {
      baton->aux2outPulseMs = (int32_t)aux2outPulseMs->NumberValue();
    }
    if (aux2outInvert->IsBoolean()) {
      baton->aux2outInvert = aux2outInvert->ToBoolean()->Value();
    }

    // attach baton to uv work request
    baton->request.data = baton;

    // assign callback to baton
    baton->callback = Persistent<Function>::New(cb);

    // queue the async function to the event loop
    // the uv default loop is the node.js event loop
    uv_queue_work(uv_default_loop(),&baton->request,Aux2outAsync,Aux2outAsyncAfter);

    // nothing returned
    return Undefined();
}

void init(Handle<Object> exports, Handle<Object> module) {

    aux2out_init();

  // add the async function to the exports for this object
  module->Set(
                String::NewSymbol("exports"),                       // javascript function name
                FunctionTemplate::New(Aux2out)->GetFunction()          // attach 'Aux2out' function to javascript name
              );
}

NODE_MODULE(aux2out, init)


